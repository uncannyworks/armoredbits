{-
    Copyright (C) 2014-2018 Uncanny Works

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-}

{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}

{-|

Module      : ArmoredBits.Network.Messages
Description : CBOR message encoding/decoding and parsing

|-}
module ArmoredBits.Network.Messages
  ( ServerEvent(..)
  , ServerMessage(..)
  , SMessage(..)
  , ClientEvent(..)
  , ClientMessage(..)
  , CMessage(..)
  , clientSend
  , clientRecv
  , serverSend
  , serverRecv
  ) where
  
--------------------------------------------------------------------------------
import Codec.CBOR.Read
import Codec.Serialise (hPutSerialise)
import Codec.Serialise.Class (Serialise, decode, encode)
import Codec.Serialise.Decoding (Decoder, decodeListLen, decodeWord)
import Codec.Serialise.Encoding (Encoding, encodeListLen, encodeWord)
import Control.Monad.ST.Strict
import qualified Data.ByteString as BS
import Data.Monoid ((<>))
import GHC.Generics
import System.IO
--------------------------------------------------------------------------------
import ArmoredBits.Types
--------------------------------------------------------------------------------

-- | 'ServerEvent's are events generated by the actual game simulation.
--
-- These message ids are odd.
data ServerEvent
  -- | State of the Server and World
  = EventServerState ServerState WorldState
  -- | Map info, etc.
  | EventServerInfo
  -- | New client joined
  | EventLogin
  -- | New object spawned
  | EventSpawn EntityId Position Rotation
  -- | Object was updated
  | EventUpdate EntityId Position Rotation
  -- | This should never happen
  | EventUnknown
  deriving (Eq, Generic, Show)

instance Serialise ServerEvent where
  encode = encodeServerEvent
  decode = decodeServerEvent

encodeServerEvent :: ServerEvent -> Encoding
encodeServerEvent (EventServerState ss ws) =
  encodeListLen 3 <> encodeWord 1 <> encode ss <> encode ws
encodeServerEvent EventServerInfo =
  encodeListLen 1 <> encodeWord 3
encodeServerEvent EventLogin =
  encodeListLen 1 <> encodeWord 5
encodeServerEvent (EventSpawn e p r) =
  encodeListLen 4 <> encodeWord 7 <> encode e <> encode p <> encode r
encodeServerEvent (EventUpdate e p r) =
  encodeListLen 4 <> encodeWord 9 <> encode e <> encode p <> encode r
encodeServerEvent EventUnknown = mempty

decodeServerEvent :: Decoder s ServerEvent
decodeServerEvent = do
  len <- decodeListLen
  tag <- decodeWord
  case (len, tag) of
    (3, 1) -> EventServerState <$> decode <*> decode
    (1, 3) -> pure EventServerInfo
    (1, 5) -> pure EventLogin
    (4, 7) -> EventSpawn <$> decode <*> decode <*> decode
    (4, 9) -> EventUpdate <$> decode <*> decode <*> decode
    _      -> pure EventUnknown

data ServerMessage
  -- | Periodic Ping from Server
  = Ping
  -- | Rate limit warning
  | Warning
  -- | Invalid token, or haven't validated token yet
  | InvalidToken
  -- | Reply for unknown messages
  | MessageUnknown
  deriving (Eq, Generic, Show)

instance Serialise ServerMessage where
  encode = encodeServerMessage
  decode = decodeServerMessage

encodeServerMessage :: ServerMessage -> Encoding
encodeServerMessage Ping =
  encodeListLen 1 <> encodeWord 1
encodeServerMessage Warning =
  encodeListLen 1 <> encodeWord 3
encodeServerMessage InvalidToken =
  encodeListLen 1 <> encodeWord 5
encodeServerMessage MessageUnknown = mempty

decodeServerMessage :: Decoder s ServerMessage
decodeServerMessage = do
  len <- decodeListLen
  tag <- decodeWord
  case (len, tag) of
    (1, 1)   -> pure Ping
    (1, 3)   -> pure Warning
    (1, 5)   -> pure InvalidToken
    _        -> pure MessageUnknown

-- | Messages which can be sent by a 'Server'.
--
-- Internal 'Server' message ids are odd.
data SMessage
  -- | Non-game specific Server message
  = MessageServer ServerMessage
  -- | Game triggered event
  | EventServer ServerEvent
  -- | This should never happen
  | SUnknown
  deriving (Eq, Generic, Show)

instance Serialise SMessage where
  encode = encodeSMessage
  decode = decodeSMessage

encodeSMessage :: SMessage -> Encoding
encodeSMessage (MessageServer m) =
  encodeListLen 2 <> encodeWord 1 <> encode m
encodeSMessage (EventServer e) =
  encodeListLen 2 <> encodeWord 101 <> encode e
encodeSMessage SUnknown = mempty

decodeSMessage :: Decoder s SMessage
decodeSMessage = do
  len <- decodeListLen
  tag <- decodeWord
  case (len, tag) of
    (2, 1)   -> MessageServer <$> decode
    (2, 101) -> EventServer <$> decode
    _        -> pure SUnknown

-- | Events sent by the 'Client'
data ClientEvent
  = ClientEventTest
  | ClientEventUnknown
  deriving (Eq, Generic, Show)

instance Serialise ClientEvent where
  encode = encodeClientEvent
  decode = decodeClientEvent

encodeClientEvent :: ClientEvent -> Encoding
encodeClientEvent ClientEventTest =
  encodeListLen 1 <> encodeWord 255
encodeClientEvent ClientEventUnknown = mempty

decodeClientEvent :: Decoder s ClientEvent
decodeClientEvent = do
  len <- decodeListLen
  tag <- decodeWord
  case (len, tag) of
    (1, 255) -> pure ClientEventTest
    _        -> pure ClientEventUnknown

data ClientMessage
  -- | Client reply to periodic Ping
  = Pong
  -- | Client sent explicit Disconnect command
  | Disconnect
  -- | Client attempts to authenticate with token
  | SendToken Token
  -- | Malformed message from Client
  | CMUnknown
  deriving (Eq, Generic, Show)

instance Serialise ClientMessage where
  encode = encodeClientMessage
  decode = decodeClientMessage

encodeClientMessage :: ClientMessage -> Encoding
encodeClientMessage Pong =
  encodeListLen 1 <> encodeWord 2
encodeClientMessage Disconnect =
  encodeListLen 1 <> encodeWord 4
encodeClientMessage (SendToken t) =
  encodeListLen 2 <> encodeWord 6 <> encode t
encodeClientMessage CMUnknown = mempty

decodeClientMessage :: Decoder s ClientMessage
decodeClientMessage = do
  len <- decodeListLen
  tag <- decodeWord
  case (len, tag) of
    (1, 2) -> pure Pong
    (1, 4) -> pure Disconnect
    (2, 6) -> SendToken <$> decode
    _      -> pure CMUnknown

-- | Messages which can be sent by a 'Client'.
--
-- Internal 'Client' message ids are even.
data CMessage
  -- | Non-game message from Client
  = MessageClient ClientMessage
  -- | Game specific message from Client
  | EventClient ClientEvent
  -- | Malformed message from Client
  | CUnknown
  deriving (Eq, Generic, Show)

instance Serialise CMessage where
  encode = encodeCMessage
  decode = decodeCMessage

encodeCMessage :: CMessage -> Encoding
encodeCMessage (MessageClient m) =
  encodeListLen 2 <> encodeWord 2 <> encode m
encodeCMessage (EventClient m) =
  encodeListLen 2 <> encodeWord 4 <> encode m
encodeCMessage CUnknown = mempty

decodeCMessage :: Decoder s CMessage
decodeCMessage = do
  len <- decodeListLen
  tag <- decodeWord
  case (len, tag) of
    (2, 2) -> MessageClient <$> decode
    (2, 4) -> EventClient <$> decode
    _      -> pure CUnknown

-- | Send a 'CMessage' from a client.
clientSend :: Handle -> CMessage -> IO ()
clientSend = writeMessage

-- | Receive a 'SMessage' from a server.
clientRecv :: Handle -> IO (Either String SMessage)
clientRecv = readMessage

-- | Send a 'SMessage' from a server.
serverSend :: Handle -> SMessage -> IO ()
serverSend = writeMessage

-- | Receive a 'CMessage' from a client.
serverRecv :: Handle -> IO (Either String CMessage)
serverRecv = readMessage

--------------------------------------------------------------------------------

-- | Incrementally stream message data from a 'Handle'
--
-- See: https://github.com/well-typed/cborg/issues/156
readMessage :: Serialise a => Handle -> IO (Either String a)
readMessage h = do
  s <- stToIO $ deserialiseIncremental decode
  streamIt h s

streamIt :: Handle -> IDecode RealWorld a -> IO (Either String a)
streamIt h (Partial k) = do
  dec <- BS.hGet h 1 >>= stToIO . k . Just
  streamIt h dec
streamIt _h (Done _ _ a) = return (Right a)
streamIt _h (Fail _ _ e) = return (Left (show e))

-- | Write a 'Message' to the socket 'Handle'
writeMessage :: Serialise a => Handle -> a -> IO ()
writeMessage = hPutSerialise
